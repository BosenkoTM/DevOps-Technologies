# Лабораторная работа №3. Развертывание аналитического сервиса в кластере Kubernetes


## 1. Цель работы
Получить практические навыки оркестрации контейнеризированных приложений в среде Kubernetes. Научиться транслировать архитектуру Docker Compose в манифесты K8s, управлять конфигурациями (ConfigMaps/Secrets), обеспечивать персистентность данных (PVC) и жизнеспособность сервисов (Probes).

## 2. Исходные данные и инструменты
Используются Docker-образы, созданные в **Лабораторной работе №2**.
Локальная среда оркестрации меняется с Docker Compose на **Minikube** (или Kind/K3s).

**Архитектура решения (Миграция из Docker Compose в K8s):**
-  **Database (Stateful):**
    *   *Compose:* Service `db` с named volume.
    *   *K8s:* Deployment (или StatefulSet) + **PersistentVolumeClaim (PVC)** + Service (ClusterIP).
-  **Analytics App (Stateless):**
    *   *Compose:* Service `app` с пробросом портов.
    *   *K8s:* Deployment (ReplicaSet) + **Service (NodePort)** + **Liveness/Readiness Probes**.
-  **Loader/Init (Ephemeral):**
    *   *Compose:* Service `loader`, запускающийся перед app.
    *   *K8s:* Объект **Job** (для разовой загрузки) или **InitContainer** внутри пода приложения (для проверки готовности БД).
-  **Configuration:**
    *   *Compose:* `.env` файл.
    *   *K8s:* Объекты **ConfigMap** (некритичные данные) и **Secret** (пароли, ключи).

## Ход работы

### Этап 1. Подготовка кластера и образов
-  Запустить Minikube: `minikube start`.
-  Перенести локальные Docker-образы из ЛР2 в среду Minikube (команда `minikube image load <image_name>` или использование локального registry), чтобы K8s мог их "видеть" без `imagePullPolicy: Always`.

### Этап 2. Управление конфигурацией и данными
-  **Secret.** Создать манифест `secret.yaml`. Перенести туда пароли от БД и API-ключи, закодированные в base64.
-  **ConfigMap.** Создать манифест `configmap.yaml`. Перенести туда несекретные переменные (хост БД, порты, настройки логирования).
-  **PVC.** Создать манифест `pvc.yaml` для базы данных (Request storage: 1Gi, AccessMode: ReadWriteOnce), чтобы данные не терялись при перезапуске пода БД.

### Этап 3. Описание Deployment и Service
-  **БД.** Написать `db-deployment.yaml`. Подключить PVC через `volumeMounts`. Подключить переменные из Secret. Создать `db-service.yaml` типа `ClusterIP` (внутренний доступ).
-  **Приложение.** Написать `app-deployment.yaml`.
    *   Настроить **InitContainer** (на базе `busybox`), который проверяет доступность сервиса БД (через `nc` или `nslookup`) перед стартом основного контейнера.
    *   Настроить **Liveness Probe** (проверка `/health`) и **Readiness Probe**.
    *   Создать `app-service.yaml` типа `NodePort` (или `LoadBalancer`), чтобы получить доступ к приложению из браузера хост-машины.

### Этап 4. Загрузка данных (Job)
Описать K8s **Job** (`loader-job.yaml`), который использует образ `loader` из ЛР2. Job должен запуститься, загрузить данные в БД и завершиться со статусом `Completed`.

---

## Варианты заданий (Кейсы)

Продолжаем работу с предметной областью из ЛР1 и ЛР2.

**Техническое задание (K8s Specific)** — особенность манифеста, которую необходимо реализовать.

| Вариант | Категория | Проектная задача (Компонент) | Техническое задание (Kubernetes Manifest Feature) |
|:---:|:---:|:---|:---|
| **1** | Финансы | Churn Prediction API | Реализовать стратегию обновления **RollingUpdate** (maxUnavailable: 1, maxSurge: 1). |
| **2** | Финансы | Crypto Dashboard | Настроить **Resource Quotas** (requests/limits) для CPU и Memory, чтобы под не "съел" весь кластер. |
| **3** | Финансы | Credit Scoring Jupyter | Использовать **NodePort** с фиксированным портом (например, 30007) для доступа к сервису. |
| **4** | Финансы | Portfolio Report Gen | Реализовать загрузчик данных как **CronJob**, запускающийся каждые 5 минут (симуляция). |
| **5** | Финансы | Fraud Redis DB | Для БД использовать тип хранилища **hostPath** (привязка к папке на ноде) вместо стандартного PVC. |
| **6** | Финансы | Branch Revenue SQL | Использовать **InitContainer** для накатывания миграций (SQL-схемы) перед стартом базы. |
| **7** | Финансы | ROI Marketing App | Настроить **Readiness Probe** так, чтобы трафик не шел на под, пока он не загрузит ML-модель в память (delay 30s). |
| **8** | Финансы | Audit Logs | Подключить **EmptyDir** volume для обмена логами между основным контейнером и sidecar-контейнером (агентом сбора логов). |
| **9** | Финансы | Liquidity App | Использовать переменные окружения через **envFrom** (загрузка всего ConfigMap сразу), а не по одной переменной. |
| **10** | Финансы | Default Prediction DB | Развернуть БД с **Replicas: 1**, но приложение с **Replicas: 3** для проверки балансировки нагрузки Service. |
| **11** | Ритейл | RFM Mongo DB | Использовать **Secret** типа `docker-registry` (симуляция пулла из закрытого реестра, даже если реестр локальный). |
| **12** | Ритейл | Market Basket Loader | Реализовать **Job** с параметром `activeDeadlineSeconds`, чтобы прервать загрузку, если она зависла. |
| **13** | Ритейл | Demand Forecast | Настроить **SecurityContext**: запуск пода от определенного User ID (fsGroup). |
| **14** | Ритейл | NLP Reviews | Использовать **PostStart Hook** для скачивания словарей NLTK сразу после старта контейнера. |
| **15** | Ритейл | Warehouse API | Настроить **Service** типа `ExternalName` (симуляция обращения к внешнему складскому API). |
| **16** | Ритейл | A/B Test Notebook | Добавить **Labels** (tier: frontend, env: dev) и использовать их в селекторах Service. |
| **17** | Ритейл | Returns Web App | Реализовать **Liveness Probe** типа `exec` (исполнение команды `cat /tmp/healthy`), а не `httpGet`. |
| **18** | Ритейл | RecSys Loader | Настроить **Job** с `backoffLimit: 4` (повторные попытки при сбое загрузки). |
| **19** | Ритейл | Sales Funnel Grafana | Развернуть Grafana, используя **ConfigMap** для подсовывания файла конфигурации (`datasource.yaml`). |
| **20** | Ритейл | Geo Analytics | Использовать **SubPath** при монтировании Volume, чтобы монтировать один файл из ConfigMap, не перекрывая всю папку. |
| **21** | Здравоохр. | Epidemic Map | Настроить **Ingress** (даже без контроллера, просто наличие манифеста) для маршрутизации по доменному имени. |
| **22** | Здравоохр. | Drug Efficiency | Использовать **Deployment** с командой `args`, переопределяющей CMD из Docker-образа. |
| **23** | Здравоохр. | Beds TimescaleDB | Настроить **StorageClass** (или использовать `standard`), явно указав его в PVC. |
| **24** | Здравоохр. | MRI TF Serving | Выделить поду GPU ресурсы (в манифесте `resources: limits: nvidia.com/gpu: 1`), даже если физически GPU нет (манифест должен быть корректным). |
| **25** | Здравоохр. | Diabetes Risk | Использовать **PreStop Hook** для корректного завершения соединений перед удалением пода. |
| **26** | Здравоохр. | Service Cost Excel | Реализовать паттерн **Sidecar**: основной контейнер генерирует отчеты, второй контейнер (nginx) их раздает. |
| **27** | Здравоохр. | Meds Inventory | Использовать **Headless Service** (ClusterIP: None) для доступа к подам БД напрямую. |
| **28** | Здравоохр. | Doctor Visits App | Настроить **TopologySpreadConstraints** (или Affinity), чтобы (теоретически) распределять поды по разным нодам. |
| **29** | Здравоохр. | MedRecord Anonymizer | Использовать **InitContainer**, который меняет права доступа (`chmod`) на примонтированном томе с данными. |
| **30** | Здравоохр. | Patient Dashboard | Реализовать **HPA (Horizontal Pod Autoscaler)** манифест (CPU target 50%). |
| **31** | Логистика | Routing OSRM | Монтировать большой файл карты через **PersistentVolume** (Static provisioning), созданный вручную, а не через Claim. |
| **32** | Логистика | Repair InfluxDB | Использовать **StatefulSet** вместо Deployment для базы данных (гарантия порядка запуска и стабильных имен). |
| **33** | Логистика | Supply Chain Dash | Настроить **Startup Probe** (для медленно стартующих приложений) в дополнение к Liveness/Readiness. |
| **34** | Энергетика | Power Weather API | Передать API-ключ через переменную окружения, ссылающуюся на **Secret Key**. |
| **35** | Энергетика | Solar Calc | Использовать **Downstream API** для передачи имени пода и IP-адреса внутрь контейнера как переменных среды. |
| **36** | Энергетика | CO2 Report Gen | Запустить генератор как **Job**, а результаты сохранить на PVC, который потом читает Nginx-под. |
| **37** | Логистика | MarineTraffic DB | Настроить **PodDisruptionBudget**, чтобы гарантировать доступность БД при обновлениях нод. |
| **38** | Энергетика | Smart Grid Sim | Использовать **Taint/Toleration** (в манифесте), чтобы разрешить запуск только на спец-нодах. |
| **39** | Логистика | Last Mile Solver | Реализовать **Multi-container Pod**: основной солвер и метрики-экспортер (Prometheus exporter). |
| **40** | Логистика | Taxi Heatmap | Настроить **ServiceAccount** для пода и привязать его в Deployment (подготовка к RBAC). |

---

## Критерии оценки 

Для получения оценки необходимо продемонстрировать работоспособность приложения в кластере Minikube и предоставить отчет.

| Критерий | Баллы | Детализация требований |
|:---|:---:|:---|
| **1. Манифесты Kubernetes (База)** | **6** | Корректно описаны Deployment для приложения и Deployment/StatefulSet для БД. Созданы Service (ClusterIP для БД, NodePort/LoadBalancer для App). Синтаксис YAML валиден. |
| **2. Конфигурация и Безопасность (Config/Secret)** | **4** | Отсутствие хардкода. Все переменные окружения (`ENV`) в подах берутся из `configMapRef` и `secretRef`. Секреты закодированы корректно. |
| **3. Хранение данных (Storage)** | **3** | Для базы данных настроен `PersistentVolumeClaim`. Продемонстрировано (в отчете), что при удалении пода БД (`kubectl delete pod`) и создании нового данные сохраняются. |
| **4. Жизненный цикл и Probes** | **3** | Настроены `LivenessProbe` и `ReadinessProbe`. Приложение не падает при старте, если БД еще не готова (использован InitContainer или логика retry). |
| **5. Специфика варианта** | **3** | Реализована и продемонстрирована специфическая техническая задача варианта (например, Job, CronJob, Sidecar, HPA и т.д.). |
| **6. Качество отчета** | **1** | Отчет содержит: описание архитектуры, листинги манифестов, скриншоты команд `kubectl get all`, `kubectl describe`, доказательство доступа к приложению через браузер/curl. |

**Итого:**
*   **0-9 баллов.** Неудовлетворительно (кластер не поднялся, манифесты с ошибками).
*   **10-14 баллов.** Удовлетворительно (приложение работает, но есть хардкод или не работает персистентность).
*   **15-20 баллов.** Хорошо/Отлично (полностью рабочая инфраструктура, выполнены все best practices).