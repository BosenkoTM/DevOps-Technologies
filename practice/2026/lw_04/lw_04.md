# Лабораторная работа №4. Автоматизация ETL-скрипта с помощью CI/CD


## Цель работы
Настроить автоматический конвейер (Pipeline) непрерывной интеграции и доставки (CI/CD) для разработанного ранее ETL-скрипта или аналитического приложения.
Научиться обеспечивать качество кода (Linting, Testing) и автоматическую сборку Docker-образов при каждом изменении в репозитории.

## Выбор инструментария

Студенту предлагается выбрать **один** из двух вариантов выполнения.
*Рекомендуется Вариант А (Локальный), так как он гарантирует независимость от внешних санкций и блокировок.*

### Вариант А. Локальный контур (Рекомендуемый)
**Инструмент.** **Jenkins** (запущенный в Docker).
**Преимущества.** Полный контроль, работает без интернета (после скачивания образов), промышленный стандарт в корпорациях РФ.
**Суть.** Вы поднимаете CI-сервер на своем компьютере, который следит за локальным Git-репозиторием (или GitHub) и выполняет задачи.

### Вариант Б. Облачный сервис (Доступный)
**Инструмент.** **GitHub Actions** или **GitVerse CI** (СберТех).
**Преимущества.** Не требует настройки сервера, быстрый старт.
**Риски.** GitHub может блокировать расширенные функции; GitVerse требует регистрации через российский ID.
**Суть.** Описание пайплайна в YAML-файле, выполнение на серверах провайдера.

---

## Ход работы (На примере Варианта А - Jenkins)

В данном сценарии мы автоматизируем проверку и упаковку компонента `loader` (ETL-скрипт) или `app` из прошлых работ.

### Этап 1. Запуск локального CI-сервера
Вам понадобится файл `docker-compose-jenkins.yml` для запуска Jenkins с возможностью управлять Docker-ом хоста (Docker-in-Docker или Socket Binding).

-  Создать директорию `jenkins_cicd` и файл `docker-compose.yml`:
    ```yaml
    version: '3'
    services:
      jenkins:
        image: jenkins/jenkins:lts
        privileged: true
        user: root
        ports:
          - 8080:8080
          - 50000:50000
        volumes:
          - jenkins_home:/var/jenkins_home
          - /var/run/docker.sock:/var/run/docker.sock # Проброс сокета для сборки образов
          - /usr/bin/docker:/usr/bin/docker # Проброс клиента Docker (для Linux)
    volumes:
      jenkins_home:
    ```
-  Запустить: `docker-compose up -d`.
-  Открыть в браузере `localhost:8080`, ввести первичный пароль (будет в логах контейнера) и установить рекомендуемые плагины.

### Этап 2. Подготовка репозитория
В корне вашего проекта (из ЛР 1-3) создать файл `Jenkinsfile` (Declarative Pipeline), который описывает стадии:

```groovy
pipeline {
    agent any
    stages {
        stage('Linting') {
            steps {
                // Проверка стиля кода (Python)
                sh 'pip install pylint'
                sh 'pylint --fail-under=5.0 src/*.py' // Не пускать дальше, если код грязный
            }
        }
        stage('Build Image') {
            steps {
                // Сборка образа с тегом номера сборки
                sh "docker build -t my-analytics-app:${BUILD_NUMBER} ."
            }
        }
        stage('Test Run') {
            steps {
                // Тестовый запуск: проверяем, что контейнер стартует и выдает версию
                sh "docker run --rm my-analytics-app:${BUILD_NUMBER} python app.py --version"
            }
        }
    }
}
```

### Этап 3. Настройка Job
-  Создать в Jenkins новый "Pipeline".
-  В разделе "Pipeline Definition" выбрать "Pipeline script from SCM".
-  Указать ссылку на ваш Git-репозиторий (если локально — путь к папке `file:///...`, если GitHub — ссылку https).
-  Запустить сборку вручную и убедиться, что она проходит успешно (зеленый цвет).

### Этап 4. Симуляция доставки (CD)
Добавить стадию `Deploy`, которая, например, обновляет запущенный контейнер в локальном Docker или пушит образ в Docker Hub (если доступен).

---

## Варианты заданий

Работа продолжает сквозной кейс. Вам необходимо реализовать Pipeline для вашего компонента.

**Задача CI/CD.** Автоматизировать рутину проверки качества и сборки.

Задания на образовательном портале [IT-Adaptive](https://envlab.ru/mod/assign/view.php?id=21)


---

## Критерии оценки

| Критерий | Баллы | Описание |
|:---|:---:|:---|
| **1. Настройка CI-инструмента** | **5** | Поднят и работает Jenkins (локально в Docker) ИЛИ настроен репозиторий с GitHub Actions. Доказательство: скриншот интерфейса Jenkins с задачей или вкладки Actions. |
| **2. Pipeline Script (Jenkinsfile/YAML)** | **5** | Создан файл конфигурации пайплайна. В нем есть минимум 3 стадии: (например, Checkout, Lint/Test, Build). Скрипт лежит в Git-репозитории. |
| **3. Реализация Quality Gate (Вариант)** | **5** | Реализована конкретная проверка из задания (Lint, Test, Security и т.д.). Продемонстрировано два запуска: **Провальный** (когда код плохой) и **Успешный** (после исправления). |
| **4. Сборка Docker-образа** | **3** | Пайплайн успешно собирает Docker-образ из материалов ЛР2. Образ виден в списке `docker images` после сборки. |
| **5. Видео-отчет** | **2** | Короткое видео (3-5 мин), где видно: запуск пайплайна, прохождение стадий, логи консоли, итог. |

---

## Требования к отчетности

Для сдачи работы необходимо предоставить:
-  **Ссылку на репозиторий**, в котором появился файл `Jenkinsfile` (или `.github/workflows/main.yml`) и файлы тестов/линтеров.
-  **Ссылку на Видео**, демонстрирующее работу автоматизации "на живую".

**Пример структуры видео:**
*   0:00 - Приветствие, демонстрация запущенного Jenkins (или GitHub).
*   0:30 - Обзор `Jenkinsfile`: какие шаги запрограммированы.
*   1:30 - Внесение "плохого" изменения в код (ошибка синтаксиса). Запуск пайплайна -> **Ошибка** (красный цвет).
*   3:00 - Исправление ошибки. Запуск пайплайна -> **Успех** (зеленый цвет).

*   4:00 - Демонстрация собранного Docker-образа в терминале.

